import{ao as I}from"./_plugin-vue_export-helper-BlgKMbjc.js";import{k as v}from"./main-T1Jwzzg3.js";class y{item;required;requiredBy;depth=0;wasted=0;type;constructor(t){this.item=t,this.required=0,this.requiredBy=new Map}setFixRequiredNumber(t){this.required=t}getFixRequiredNumber(){return this.required}requiredNumber(){let t=this.required;for(const i of this.requiredBy.values())t+=i;return t}addRequiredBy(t,i){const s=this.requiredBy.get(t)??0;this.requiredBy.set(t,s+i)}}const B=I("bom",{state:()=>({targetItems:[],holdingItems:new Map,recipeCache:new Map,ingredientsCache:new Map,itemInfoCache:new Map,ingredients:[],fetchingItem:void 0}),actions:{addTarget(...o){for(const t of o){const i=new y(t);i.setFixRequiredNumber(1),this.targetItems.push(i)}},removeTarget(o){this.targetItems.splice(o,1)},async updateBom(){const t=await v().getDataSource();for(const e of this.targetItems)e.requiredBy.clear();const i=[...this.targetItems],s=new Map(i.map(e=>[e.item.id,e])),m=new Map;for(;i.length>0;){const e=i.shift();s.set(e.item.id,e),this.fetchingItem=e.item.name;const n=await this.findRecipe(t,e.item.id,e.item.name);if(n.length==0)continue;const d=n[0],a=await this.fetchIngredients(t,d.id);for(const r of a){let h=s.get(r.ingredient_id);if(h==null){const u=await this.fetchItemInfo(t,r.ingredient_id);h=new y(u),s.set(u.id,h)}i.push(h)}m.set(e.item.id,a.map(r=>r.ingredient_id))}this.fetchingItem=void 0;const c=new Map;for(const e of m.values())e.forEach(n=>{c.set(n,(c.get(n)??0)+1)});for(const e of s.values())(c.get(e.item.id)??0)==0&&i.push(e);const g=[];for(;i.length>0;){const e=i.shift();g.push(e);const n=m.get(e.item.id);if(n!=null)for(const d of n){const a=c.get(d)-1;c.set(d,a),a==0&&i.push(s.get(d))}}if(g.length!=s.size)throw new Error("Topology sorting failed");const l=new Map(this.holdingItems),f=new Map;for(const e of g){const n=e.requiredNumber(),d=l.get(e.item.id)??0,a=Math.min(n,d);l.set(e.item.id,d-a);const r=n-a;e.type=n>0?r>0?"required":"completed":"not-required";const h=await this.findRecipe(t,e.item.id,e.item.name);if(h.length==0){e.wasted=0;continue}const u=h[0];if(u.item_amount==null)throw"unsupported data source";const w=Math.ceil(r/u.item_amount);e.wasted=u.item_amount*w-r;for(const q of await this.fetchIngredients(t,u.id)){const p=s.get(q.ingredient_id);p.addRequiredBy(e.item.id,w*q.amount),f.set(p.item.id,Math.max(f.get(p.item.id)??0,(f.get(e.item.id)??0)+1))}}for(const e of g.toReversed()){if(e.depth=f.get(e.item.id)??0,e.type!="required")continue;const n=m.get(e.item.id),d=a=>{const r=s.get(a)?.type;return r=="completed"||r=="crafted"};n!=null&&n.every(d)&&(e.type="crafted")}this.ingredients=g},async findRecipe(o,t,i){let s=this.recipeCache.get(t);return s!=null||(s=(await o.recipeTable(1,i)).results.filter(c=>c.item_id==t),this.recipeCache.set(t,s)),s},async fetchIngredients(o,t){let i=this.ingredientsCache.get(t);return i==null&&(i=await o.recipesIngredients(t),this.ingredientsCache.set(t,i)),i.filter(s=>s.ingredient_id>=20)},async fetchItemInfo(o,t){let i=this.itemInfoCache.get(t);return i==null&&(i=await o.itemInfo(t),this.itemInfoCache.set(t,i)),i}}});export{B as u};
//# sourceMappingURL=bom-aywFtSty.js.map
