{"version":3,"file":"bom-DgmNImyt.js","sources":["../../src/stores/bom.ts"],"sourcesContent":["// This file is part of BestCraft.\n// Copyright (C) 2024 Tnze\n//\n// BestCraft is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// BestCraft is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport { defineStore } from 'pinia';\n\nimport useSettingStore from '@/stores/settings';\nimport { DataSource } from '@/datasource/source';\nimport { ItemWithAmount, RecipeInfo } from '@/libs/Craft';\n\nexport type ItemID = number;\nexport type RecipeID = number;\n\nexport interface Item {\n    id: ItemID;\n    name: string;\n}\n\nexport type SlotType = 'completed' | 'crafted' | 'required' | 'not-required';\n\nexport class Slot {\n    item: Item;\n    required: number;\n    requiredBy: Map<ItemID, number>; // itemID, amount\n    depth: number = 0;\n    wasted: number = 0;\n    type?: SlotType;\n\n    constructor(item: Item) {\n        this.item = item;\n        this.required = 0;\n        this.requiredBy = new Map();\n    }\n\n    setFixRequiredNumber(n: number) {\n        this.required = n;\n    }\n\n    getFixRequiredNumber() {\n        return this.required;\n    }\n\n    requiredNumber(): number {\n        let sum = this.required;\n        for (const amount of this.requiredBy.values()) {\n            sum += amount;\n        }\n        return sum;\n    }\n\n    addRequiredBy(item: ItemID, amount: number) {\n        const oldAmount = this.requiredBy.get(item) ?? 0;\n        this.requiredBy.set(item, oldAmount + amount);\n    }\n}\n\nexport default defineStore('bom', {\n    state: () => ({\n        targetItems: <Slot[]>[],\n        holdingItems: new Map<ItemID, number>(), // item -> amount\n\n        recipeCache: new Map<ItemID, RecipeInfo[]>(),\n        ingredientsCache: new Map<RecipeID, ItemWithAmount[]>(),\n        itemInfoCache: new Map<ItemID, Item>(),\n        ingredients: <Slot[]>[],\n\n        fetchingItem: <string | undefined>undefined,\n    }),\n\n    actions: {\n        addTarget(...items: Item[]) {\n            for (const item of items) {\n                const slot = new Slot(item);\n                slot.setFixRequiredNumber(1);\n                this.targetItems.push(slot);\n            }\n        },\n\n        removeTarget(i: number) {\n            this.targetItems.splice(i, 1);\n        },\n\n        async updateBom() {\n            const settingStore = useSettingStore();\n            const ds = await settingStore.getDataSource();\n\n            for (const slot of this.targetItems) {\n                slot.requiredBy.clear();\n            }\n\n            // Discovering crafting DAG\n            const queue = [...this.targetItems];\n            const ings = new Map<ItemID, Slot>(queue.map(v => [v.item.id, v]));\n            const successors = new Map<ItemID, ItemID[]>();\n            while (queue.length > 0) {\n                const v = queue.shift()!;\n                ings.set(v.item.id, v);\n\n                this.fetchingItem = v.item.name;\n\n                const recipes = await this.findRecipe(\n                    ds,\n                    v.item.id,\n                    v.item.name,\n                );\n                if (recipes.length == 0) continue;\n\n                const r = recipes[0];\n                const subIngs = await this.fetchIngredients(ds, r.id);\n\n                for (const subIng of subIngs) {\n                    let slot = ings.get(subIng.ingredient_id);\n                    if (slot == undefined) {\n                        const itemInfo = await this.fetchItemInfo(\n                            ds,\n                            subIng.ingredient_id,\n                        );\n                        slot = new Slot(itemInfo);\n                        ings.set(itemInfo.id, slot);\n                    }\n                    queue.push(slot);\n                }\n                successors.set(\n                    v.item.id,\n                    subIngs.map(v => v.ingredient_id),\n                );\n            }\n            this.fetchingItem = undefined;\n\n            // Sorting with Kahn's algorithm\n            const indegrees = new Map<ItemID, number>();\n            for (const v of successors.values()) {\n                v.forEach(successor => {\n                    indegrees.set(\n                        successor,\n                        (indegrees.get(successor) ?? 0) + 1,\n                    );\n                });\n            }\n            for (const ing of ings.values()) {\n                if ((indegrees.get(ing.item.id) ?? 0) == 0) {\n                    queue.push(ing);\n                }\n            }\n            const sorted = [];\n            while (queue.length > 0) {\n                const v = queue.shift()!;\n                sorted.push(v);\n\n                const ss = successors.get(v.item.id);\n                if (ss != undefined) {\n                    for (const successor of ss!) {\n                        const newIndegree = indegrees.get(successor)! - 1;\n                        indegrees.set(successor, newIndegree);\n                        if (newIndegree == 0) {\n                            queue.push(ings.get(successor)!);\n                        }\n                    }\n                }\n            }\n            if (sorted.length != ings.size) {\n                throw new Error('Topology sorting failed');\n            }\n\n            // Calculate amounts\n            const holdings = new Map(this.holdingItems);\n            const depths = new Map<ItemID, number>();\n            for (const slot of sorted) {\n                // calculate needs\n                const r = slot.requiredNumber(); // required\n                const h = holdings.get(slot.item.id) ?? 0; // holding\n                const use = Math.min(r, h);\n                holdings.set(slot.item.id, h - use);\n                const n = r - use; // needs\n                slot.type =\n                    r > 0 ? (n > 0 ? 'required' : 'completed') : 'not-required';\n                // find recipe\n                const recipes = await this.findRecipe(\n                    ds,\n                    slot.item.id,\n                    slot.item.name,\n                );\n                if (recipes.length == 0) {\n                    slot.wasted = 0;\n                    continue;\n                }\n                const recipe = recipes[0];\n                if (recipe.item_amount == undefined)\n                    throw 'unsupported data source';\n                const crafts = Math.ceil(n / recipe.item_amount);\n                slot.wasted = recipe.item_amount * crafts - n;\n\n                for (const ing of await this.fetchIngredients(ds, recipe.id)) {\n                    const subSlot = ings.get(ing.ingredient_id)!;\n                    subSlot.addRequiredBy(slot.item.id, crafts * ing.amount);\n\n                    depths.set(\n                        subSlot.item.id,\n                        Math.max(\n                            depths.get(subSlot.item.id) ?? 0,\n                            (depths.get(slot.item.id) ?? 0) + 1,\n                        ),\n                    );\n                }\n            }\n\n            // Coloring / Depthing\n            for (const slot of sorted.toReversed()) {\n                slot.depth = depths.get(slot.item.id) ?? 0;\n                if (slot.type != 'required') {\n                    continue;\n                }\n                const ss = successors.get(slot.item.id);\n                const isEnough = (s: number) => {\n                    const typ = ings.get(s)?.type;\n                    return typ == 'completed' || typ == 'crafted';\n                };\n                if (ss != undefined && ss.every(isEnough)) {\n                    slot.type = 'crafted';\n                }\n            }\n\n            this.ingredients = sorted;\n        },\n\n        async findRecipe(\n            dataSource: DataSource,\n            itemId: ItemID,\n            itemName: string,\n        ): Promise<RecipeInfo[]> {\n            let result = this.recipeCache.get(itemId); // read cache\n            if (result != undefined) {\n                return result;\n            }\n\n            // TODO: be smarter, get rid of itemName\n            const table = await dataSource.recipeTable(1, itemName);\n            result = table.results.filter(v => v.item_id == itemId);\n\n            this.recipeCache.set(itemId, result); // write cache\n            return result;\n        },\n\n        async fetchIngredients(dataSource: DataSource, recipeId: RecipeID) {\n            let result = this.ingredientsCache.get(recipeId);\n            if (result == undefined) {\n                result = await dataSource.recipesIngredients(recipeId);\n                this.ingredientsCache.set(recipeId, result);\n            }\n            return result.filter(v => v.ingredient_id >= 20); // 过滤偏属性水晶\n        },\n\n        async fetchItemInfo(\n            dataSource: DataSource,\n            itemId: ItemID,\n        ): Promise<Item> {\n            let result = this.itemInfoCache.get(itemId);\n            if (result == undefined) {\n                result = await dataSource.itemInfo(itemId);\n                this.itemInfoCache.set(itemId, result);\n            }\n            return result;\n        },\n    },\n});\n"],"names":["Slot","item","n","sum","amount","oldAmount","useBomStore","defineStore","items","slot","i","ds","useSettingStore","queue","ings","v","successors","recipes","r","subIngs","subIng","itemInfo","indegrees","successor","ing","sorted","ss","newIndegree","holdings","depths","h","use","recipe","crafts","subSlot","isEnough","s","typ","dataSource","itemId","itemName","result","recipeId"],"mappings":"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"}